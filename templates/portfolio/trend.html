{% extends "base.html" %}
{% block title %}銘柄トレンド判定{% endblock %}

{% block head %}
  <!-- このページ専用：Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin: 12px;
      background: #0b0f1a; /* ダーク背景 */
      color: #f1f5f9;      /* 明るめ文字 */
    }

    /* 見出し */
    h2 {
      font-size: 22px;
      margin: 0 0 16px;
      font-weight: 600;
      color: #fff;
    }

    /* 入力とボタン */
    input[type=text] {
      flex: 1;
      font-size: 16px;
      padding: 14px 12px;
      border: 1px solid #334155;
      border-radius: 12px;
      background: #1e293b;
      color: #fff;
    }
    button {
      padding: 14px 18px;
      font-size: 15px;
      border: none;
      border-radius: 12px;
      background: #2563eb;
      color: #fff;
      font-weight: 600;
    }
    button:hover { background: #1d4ed8; }

    /* カード */
    .card {
      margin-top: 14px;
      border-radius: 14px;
      padding: 16px;
      background: rgba(255,255,255,0.05);
      backdrop-filter: blur(12px);
      box-shadow: 0 2px 8px rgba(0,0,0,.4);
    }

    /* サブテキスト */
    .sub { color: #94a3b8; font-size: 13px; }

    /* チャート */
    .chart-wrap {
      margin-top: 16px;
      border-radius: 16px;
      padding: 12px;
      height: 300px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
    }

    /* KPIグリッド → 横スクロール */
    .grid { display: flex; overflow-x: auto; gap: 10px; padding-bottom: 6px; }
    .kpi {
      min-width: 140px; flex-shrink: 0; padding: 12px; border-radius: 12px;
      background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
    }
    .kpi h4 { margin: 0 0 4px; font-size: 12px; color: #cbd5e1; }
    .kpi .v { font-size: 16px; font-weight: 600; color: #fff; }

    /* バッジ */
    .badge { display: inline-block; padding: 2px 10px; border-radius: 999px; font-size: 12px; font-weight: 600; }
    .b-green { background:#16a34a; color:#fff; }
    .b-red   { background:#dc2626; color:#fff; }
    .b-gray  { background:#334155; color:#e2e8f0; }

    /* 判定バッジ */
    .badge-decision {
      display:inline-block; padding: 6px 14px; border-radius: 999px;
      font-size: 14px; font-weight: 700; color:#fff;
    }
    .badge-buy   { background:#16a34a; }
    .badge-watch { background:#facc15; color:#222; }
    .badge-skip  { background:#ef4444; }

    /* ポジションサイズ */
    #ev-sizing {
      margin-top: 14px; padding: 12px; border-radius: 12px;
      background: rgba(255,255,255,0.06); font-size: 14px;
    }
    #ev-sizing h4 { margin: 0 0 6px; font-size: 13px; color: #cbd5e1; }

    /* フォーム系 */
    .row { display:flex; gap:8px; align-items:center; }
    .btn-primary { background:#2563eb; color:#fff; font-weight:700; border:none; border-radius:12px; padding:14px 18px; }
    .btn-primary:disabled { opacity:.5; }

    .field-inline { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .num-input {
      width:120px; padding:10px; border-radius:10px; background:#1e293b; color:#fff; border:1px solid #334155;
    }
  </style>

  <!-- HTMX への CSRF 自動付与（このページだけで完結させる版） -->
  <script>
    function _getCookie(name){
      const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return v ? v.pop() : '';
    }
    document.addEventListener('DOMContentLoaded', () => {
      document.body.addEventListener('htmx:configRequest', (e) => {
        const token = _getCookie('csrftoken');
        if (token) e.detail.headers['X-CSRFToken'] = token;
      });
    });
  </script>
{% endblock %}

{% block content %}
  <h2>銘柄トレンド判定</h2>

  <div class="row">
    <input id="ticker" type="text" placeholder="例: AAPL / MSFT / 7203（.T不要）"
           inputmode="latin" autocomplete="off" autocapitalize="characters" spellcheck="false">
    <button id="judgeBtn"
      hx-get="/trend/card"
      hx-target="#result"
      hx-swap="innerHTML"
      hx-indicator="#loading"
      hx-vals='js:{"ticker": document.getElementById("ticker").value.trim()}'>
      判定
    </button>
  </div>

  <div id="loading" class="sub htmx-indicator">Loading...</div>

  <!-- 判定結果カード（HTMX差し替え） -->
  <div id="result" class="card"></div>

  <!-- チャート -->
  <div class="chart-wrap">
    <canvas id="priceChart"></canvas>
  </div>

  <!-- 根拠 + 意思決定 -->
  <div id="evidence" class="card" style="display:none;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
      <div class="sub" id="ev-asof"></div>
      <div id="ev-decision"></div>
    </div>
    <div class="grid" id="ev-grid"></div>
    <div id="ev-sizing"></div>
    <div id="ev-error" class="err" style="display:none;"></div>
  </div>

  <!-- 方向（買い/売り）トグル -->
  <div style="display:flex;gap:8px;margin-top:10px;">
    <button id="sideLong"  class="badge b-green" onclick="setSide('LONG')">買い</button>
    <button id="sideShort" class="badge b-red"   onclick="setSide('SHORT')">売り</button>
  </div>

  <!-- 数量（提案が0の時はここに手入力） -->
  <div class="field-inline">
    <label class="sub" for="planQty">数量</label>
    <input id="planQty" type="number" min="1" step="1" class="num-input" placeholder="例: 100">
    <span class="sub" id="planQtyHint"></span>
  </div>

  <!-- 保存結果メッセージ -->
  <div id="planMsg" class="sub" style="margin-top:8px;"></div>

  <!-- 注文プランに追加 -->
  <button
    class="btn-primary" style="width:100%;margin-top:10px;"
    hx-post="/api/positions/add"
    hx-vals='js:buildPositionPayload()'
    hx-target="#planMsg"
    hx-swap="innerHTML">
    📥 注文プランに追加
  </button>

  <script>
    const tickerEl = document.getElementById('ticker');
    const btn = document.getElementById('judgeBtn');

    function normalizeTicker(raw){
      const t = (raw || '').trim().toUpperCase();
      if (!t) return t;
      if (t.includes('.')) return t;
      return /^[0-9A-Z]{4,5}$/.test(t) ? `${t}.T` : t;
    }
    tickerEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') btn.click(); });

    let chart;
    async function drawChart(input, days = 180) {
      const ticker = normalizeTicker(input);
      if (!ticker) return;

      try {
        const r = await fetch(`/api/ohlc?ticker=${encodeURIComponent(ticker)}&days=${days}`);
        const j = await r.json();

        const ctx = document.getElementById('priceChart').getContext('2d');
        if (chart) chart.destroy();

        if (!(j.ok && Array.isArray(j.labels) && j.labels.length)){
          document.querySelector('.chart-wrap').innerHTML =
            '<div style="color:#b00020;padding:8px;">チャートデータが取得できませんでした。</div>';
          return;
        }

        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: j.labels,
            datasets: [
              { label: 'Close', data: j.close, borderWidth: 2, pointRadius: 0 },
              { label: 'MA(10)', data: j.ma10, borderWidth: 1, pointRadius: 0, spanGaps: true },
              { label: 'MA(30)', data: j.ma30, borderWidth: 1, pointRadius: 0, spanGaps: true }
            ]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: { x: { display: false }, y: { beginAtZero: false, ticks: { callback: v => (typeof v === 'number'? v.toLocaleString(): v) } } },
            plugins: { legend: { display: true } }
          }
        });

        // 推奨建値/損切ライン/スイングのライン
        try {
          const mres = await fetch(`/api/metrics?ticker=${encodeURIComponent(ticker)}`);
          const m = await mres.json();
          if (m.ok && m.levels){
            const n = j.labels.length;
            const pushLine = (label, val, color, dash=[6,4]) => {
              if (val == null) return;
              chart.data.datasets.push({
                type: 'line',
                label,
                data: Array(n).fill(Number(val)),
                borderWidth: 1.5,
                borderColor: color,
                pointRadius: 0,
                borderDash: dash
              });
            };
            pushLine('推奨建値',   m.levels.entry, '#16a34a', [4,4]);
            pushLine('損切ライン', m.levels.stop,  '#ef4444', [6,4]);
            pushLine('Swing High', m.levels.swing_high, '#60a5fa', [2,4]);
            pushLine('Swing Low',  m.levels.swing_low,  '#a78bfa', [2,4]);
            chart.update();
          }
        } catch(e){ console.warn('metrics overlay failed', e); }

      } catch(e) {
        const box = document.querySelector('.chart-wrap');
        box.innerHTML = '<div style="color:#b00020;padding:8px;">チャート描画中にエラーが発生しました。</div>';
        console.error(e);
      }
    }

    // ===== Evidence =====
    function smallBadge(text, tone){
      const cls = tone === 'green' ? 'b-green' : tone === 'red' ? 'b-red' : 'b-gray';
      return `<span class="badge ${cls}">${text}</span>`;
    }
    function decisionBadge(label){
      if (label === 'BUY')   return `<span class="badge-decision badge-buy">✅ 買い候補</span>`;
      if (label === 'AVOID') return `<span class="badge-decision badge-skip">🚫 見送り</span>`;
      return `<span class="badge-decision badge-watch">👀 観察</span>`;
    }
    function fmt(x, d=2){ return (x===null || x===undefined) ? '-' : Number(x).toFixed(d); }

    async function loadEvidence(input){
      const ticker = normalizeTicker(input);
      const box = document.getElementById('evidence');
      const grid = document.getElementById('ev-grid');
      const asof = document.getElementById('ev-asof');
      const err  = document.getElementById('ev-error');
      const dec  = document.getElementById('ev-decision');
      const sizingBox = document.getElementById('ev-sizing');
      box.style.display = 'none';
      err.style.display = 'none'; err.textContent = ''; dec.innerHTML = ''; sizingBox.innerHTML = '';

      try{
        const r = await fetch(`/api/metrics?ticker=${encodeURIComponent(ticker)}`);
        const j = await r.json();
        if(!j.ok){
          err.textContent = j.error || 'メトリクス取得に失敗しました';
          err.style.display = 'block';
          box.style.display = 'block';
          return;
        }
        asof.textContent = `根拠（${j.asof} 時点）`;
        grid.innerHTML = '';

        // 意思決定
        const slope = j.trend?.slope_ann_pct_60 ?? 0;
        const adx = j.trend?.adx14 ?? 0;
        let label = 'WATCH';
        if (slope > 0 && adx >= 20) label = 'BUY';
        else if (slope < 0) label = 'AVOID';
        dec.innerHTML = decisionBadge(label);

        // KPI群
        const ma = j.trend?.ma || {};
        const maStack = ma.stack === 'bull' ? smallBadge('MA整列:強','green')
                       : ma.stack === 'bear' ? smallBadge('MA整列:弱','red')
                       : smallBadge('MA整列:中立','gray');
        grid.insertAdjacentHTML('beforeend', `
          <div class="kpi"><h4>回帰傾き(60日・年率)</h4><div class="v">${fmt(slope)}%</div></div>
          <div class="kpi"><h4>ADX(14)</h4><div class="v">${fmt(adx)}</div></div>
          <div class="kpi"><h4>MA20/50/200</h4><div class="v">${fmt(ma["20"],0)} / ${fmt(ma["50"],0)} / ${fmt(ma["200"],0)}</div></div>
          <div class="kpi"><h4>MA整列</h4><div class="v">${maStack}</div></div>
        `);

        const rs6 = j.relative?.rs_6m_pct;
        const nearHigh = j.relative?.from_52w_high_pct ?? null;
        const nearLow  = j.relative?.from_52w_low_pct  ?? null;
        grid.insertAdjacentHTML('beforeend', `
          <div class="kpi"><h4>RS(6M,指数比)</h4><div class="v">${fmt(rs6)}%</div></div>
          <div class="kpi"><h4>52週高値まで</h4><div class="v">${fmt(nearHigh)}%</div></div>
          <div class="kpi"><h4>52週安値から</h4><div class="v">${fmt(nearLow)}%</div></div>
        `);

        const vol20 = j.risk?.vol20_ann_pct, vol60 = j.risk?.vol60_ann_pct, atr = j.risk?.atr14;
        const adv20 = j.liquidity?.adv20;
        const lv = j.levels || {};
        grid.insertAdjacentHTML('beforeend', `
          <div class="kpi"><h4>年化ボラ20</h4><div class="v">${fmt(vol20)}%</div></div>
          <div class="kpi"><h4>年化ボラ60</h4><div class="v">${fmt(vol60)}%</div></div>
          <div class="kpi"><h4>ATR(14)</h4><div class="v">${fmt(atr,0)}</div></div>
          <div class="kpi"><h4>ADV20(売買代金)</h4><div class="v">${adv20 ? adv20.toLocaleString() : '-'}</div></div>
          <div class="kpi"><h4>推奨建値</h4><div class="v">${lv.entry ? lv.entry.toLocaleString() : '-'}</div></div>
          <div class="kpi"><h4>損切ライン</h4><div class="v">${lv.stop ? lv.stop.toLocaleString() : '-'}</div></div>
        `);

        // ポジションサイズ情報
        if (j.sizing){
          const sz = j.sizing;
          const eq = typeof sz.equity === 'number' ? sz.equity : null;
          const rp = typeof sz.risk_pct === 'number' ? sz.risk_pct : null;
          document.getElementById('planQtyHint').textContent =
            (sz.qty && sz.qty > 0) ? `提案: ${sz.qty} 株（単元:${sz.lot ?? '-'}）` : '数量の提案なし';
          const hintEl = document.getElementById('planQty');
          if (hintEl && (!hintEl.value || Number(hintEl.value) === 0) && sz.qty > 0){
            hintEl.value = sz.qty; // 自動提案を初期値として入れておく
          }
          document.getElementById('ev-sizing').innerHTML = `
            <h4>ポジションサイズ試算</h4>
            <div class="sub">口座残高: ¥${eq !== null ? eq.toLocaleString() : '-'} / リスク: <b>${rp ?? '-' }%</b></div>
            <div>数量: <b>${(sz.qty ?? 0).toLocaleString()}</b> 株 (単元:${sz.lot ?? '-'})</div>
            <div>必要資金: ¥${(sz.notional ?? 0).toLocaleString()}</div>
            <div>想定損失(Stop): ¥${(sz.expected_loss_at_stop ?? 0).toLocaleString()}</div>
          `;
        } else {
          document.getElementById('planQtyHint').textContent = '数量の提案なし';
          document.getElementById('ev-sizing').innerHTML =
            `<div class="sub">⚠️ ポジションサイズを算出できません（資金設定が未保存・または推奨建値/損切ライン不足）。</div>`;
        }

        // ここで “現在の銘柄＆メトリクス” を保持（ボタン押下時に使う）
        CURRENT.ticker = ticker;
        CURRENT.lastMetrics = j;

        box.style.display = 'block';
      }catch(e){
        const errBox = document.getElementById('ev-error');
        errBox.textContent = `メトリクス取得エラー: ${e}`;
        errBox.style.display = 'block';
        document.getElementById('evidence').style.display = 'block';
      }
    }

    // HTMX: カード更新後にチャートと根拠を同期
    document.body.addEventListener('htmx:afterOnLoad', () => {
      const t = tickerEl.value.trim();
      if (t){
        drawChart(t);
        loadEvidence(t);
      }
    });
  </script>

  <script>
    // ===== 注文プラン（Position登録）用の共有状態 =====
    let CURRENT = { ticker: "", side: "LONG", lastMetrics: null };

    function setSide(s){
      CURRENT.side = s;
      document.getElementById('sideLong').style.opacity  = (s==='LONG'? '1':'0.6');
      document.getElementById('sideShort').style.opacity = (s==='SHORT'?'1':'0.6');
    }

    function buildPositionPayload(){
      const m  = CURRENT.lastMetrics || {};
      const lv = m.levels || {};
      const sz = m.sizing || {};

      const qtyInput = Number(document.getElementById('planQty').value || 0);
      const qtyAuto  = Number(sz.qty || 0);
      const qty = qtyInput > 0 ? qtyInput : qtyAuto;

      // エラーメッセージ（見える化）
      const msgBox = document.getElementById('planMsg');
      msgBox.textContent = '';
      if (!lv.entry || !lv.stop){
        msgBox.textContent = '推奨建値または損切ラインが取得できません。';
      }
      if (qty <= 0){
        msgBox.textContent = '数量が未設定です。提案が0のため、数量を入力してください。';
      }

      return {
        ticker: CURRENT.ticker || document.getElementById('ticker').value.trim(),
        side: CURRENT.side,
        entry: lv.entry ? Number(lv.entry) : null,   // 推奨建値
        stop:  lv.stop  ? Number(lv.stop)  : null,   // 損切ライン
        qty:   qty,
        "targets[]": (m.targets || []).map(Number),  // 利確めやす（存在すれば）
        sync_holding: false,
        account_type: "margin",
      };
    }

    // HTMXのレスポンスをメッセージに反映
    document.body.addEventListener('htmx:afterRequest', (e) => {
      if (e?.detail?.xhr?.responseURL?.includes('/api/positions/add')) {
        const box = document.getElementById('planMsg');
        try {
          const j = JSON.parse(e.detail.xhr.responseText || '{}');
          if (j.ok) box.textContent = '✅ 注文プランを保存しました。/positions/ に反映されています。';
          else box.textContent = '❌ 保存に失敗: ' + (j.error || 'unknown error');
        } catch(_) {
          box.textContent = e.detail.xhr.responseText || '❌ 保存に失敗しました';
        }
      }
    });
  </script>
{% endblock %}
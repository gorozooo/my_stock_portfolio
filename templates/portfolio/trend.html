<!-- templates/portfolio/trend.html -->
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>銘柄トレンド判定</title>

  <script src="https://unpkg.com/htmx.org@1.9.12"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>

  <style>
    body { font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial; margin:16px; }
    h2 { font-size:28px; margin:0 0 12px; }
    .row { display:flex; gap:8px; }
    input[type=text]{ flex:1; font-size:16px; padding:12px; border:1px solid #ddd; border-radius:12px; }
    button{ padding:12px 16px; font-size:16px; border:none; border-radius:12px; background:#111; color:#fff; }
    .card{ margin-top:12px; border:1px solid #eee; border-radius:16px; padding:16px; box-shadow:0 2px 8px rgba(0,0,0,.06);}
    .tag{ display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; }
    .up{ background:#e6ffed; color:#057a55; }
    .down{ background:#ffecec; color:#b00020; }
    .flat{ background:#f5f5f5; color:#555; }
    .sub{ color:#666; font-size:12px; }
    .chart-wrap { margin-top:12px; border:1px solid #eee; border-radius:16px; padding:12px; height:360px; }
    .htmx-indicator { display:none; }
    .htmx-request .htmx-indicator { display:block; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .kpi { padding:10px; border:1px solid #eee; border-radius:12px; background:#fafafa; }
    .kpi h4 { margin:0 0 6px; font-size:13px; color:#666; }
    .kpi .v { font-size:16px; font-weight:600; }

    .badge { display:inline-block; padding:2px 10px; border-radius:999px; font-size:12px; }
    .b-green{ background:#e6ffed; color:#057a55; }
    .b-red{ background:#ffecec; color:#b00020; }
    .b-gray{ background:#f5f5f5; color:#555; }
    .err { color:#b00020; margin-top:8px; }

    /* 意思決定の大きめバッジ（前段で導入済み） */
    .badge-decision { display:inline-block; padding:6px 12px; border-radius:999px; font-size:14px; font-weight:600; color:#fff; }
    .badge-buy   { background:#26d07c; }   /* 緑 */
    .badge-watch { background:#f4c542; }   /* 黄 */
    .badge-skip  { background:#ff4d4f; }   /* 赤 */
  </style>
</head>
<body>
  <h2>銘柄トレンド判定</h2>

  <div class="row">
    <input id="ticker" type="text" placeholder="例: AAPL / MSFT / 7203（.T不要）"
           inputmode="latin" autocomplete="off" autocapitalize="characters" spellcheck="false">
    <button id="judgeBtn"
      hx-get="/trend/card"
      hx-target="#result"
      hx-swap="innerHTML"
      hx-indicator="#loading"
      hx-vals='js:{"ticker": document.getElementById("ticker").value.trim()}'>
      判定
    </button>
  </div>

  <div id="loading" class="sub htmx-indicator">Loading...</div>

  <!-- 判定結果カード -->
  <div id="result" class="card"></div>

  <!-- チャート -->
  <div class="chart-wrap">
    <canvas id="priceChart"></canvas>
  </div>

  <!-- 根拠 + エントリー/損切り/利確 -->
  <div id="evidence" class="card" style="display:none;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
      <div class="sub" id="ev-asof"></div>
      <div id="ev-decision"></div>
    </div>
    <div class="grid" id="ev-grid"></div>
    <div id="ev-error" class="err" style="display:none;"></div>
  </div>

  <script>
    const tickerEl = document.getElementById('ticker');
    const btn = document.getElementById('judgeBtn');

    function normalizeTicker(raw){
      const t = (raw || '').trim().toUpperCase();
      if (!t) return t;
      if (t.includes('.')) return t;
      return /^[0-9A-Z]{4,5}$/.test(t) ? `${t}.T` : t;
    }
    tickerEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') btn.click(); });

    // ===== チャート描画 =====
    let chart;
    let latestTrade = null; // {entry, stop, take} を保持してラインに使う

    function makeConstLine(len, y){
      if (y == null) return null;
      return Array.from({length: len}, () => y);
    }

    function addTradeLinesToDatasets(datasets, len){
  if (!latestTrade) return datasets;
  const {entry, stop, take} = latestTrade;
  const ds = [...datasets];
  const baseOpt = {borderWidth: 1.5, pointRadius: 0, spanGaps: true};

  if (entry != null){
    const entryLine = Array(len).fill(entry);
    ds.push({ label: 'Entry', data: entryLine, ...baseOpt, borderColor:'#444', borderDash:[6,4] });
  }
  if (stop != null){
    const stopLine = Array(len).fill(stop);
    ds.push({ label: 'Stop', data: stopLine, ...baseOpt, borderColor:'#d00', borderDash:[4,4] });
  }
  if (take != null){
    const takeLine = Array(len).fill(take);
    ds.push({ label: 'Take', data: takeLine, ...baseOpt, borderColor:'#0a0', borderDash:[2,4] });
  }
  return ds;
}

    async function drawChart(input, days = 180) {
      const ticker = normalizeTicker(input);
      if (!ticker) return;
      try {
        // /api/ohlc で価格データ
        const r = await fetch(`/api/ohlc?ticker=${encodeURIComponent(ticker)}&days=${days}`);
        const j = await r.json();
        const el = document.getElementById('priceChart');
        const ctx = el.getContext('2d');
        if (chart) chart.destroy();

        if (j.ok && Array.isArray(j.labels) && j.labels.length){
          // 長さ確定後にライン用データ生成
          const labels = j.labels;
          let datasets = [
            { label: 'Close', data: j.close, borderWidth: 2, pointRadius: 0 },
            { label: 'MA(10)', data: j.ma10, borderWidth: 1, pointRadius: 0, spanGaps: true },
            { label: 'MA(30)', data: j.ma30, borderWidth: 1, pointRadius: 0, spanGaps: true }
          ];
          datasets = addTradeLinesToDatasets(datasets, labels.length);

          chart = new Chart(ctx, {
            type: 'line',
            data: { labels, datasets },
            options: {
              responsive: true, maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              scales: { x: { display: false }, y: { beginAtZero: false, ticks: { callback: v => (typeof v === 'number'? v.toLocaleString(): v) } } },
              plugins: { legend: { display: true } }
            }
          });
        } else {
          document.querySelector('.chart-wrap').innerHTML =
            '<div style="color:#b00020;padding:8px;">チャートデータが取得できませんでした。</div>';
        }
      } catch(e) {
        document.querySelector('.chart-wrap').innerHTML =
          '<div style="color:#b00020;padding:8px;">チャート描画中にエラーが発生しました。</div>';
        console.error(e);
      }
    }

    // ===== Evidence（軽量根拠 + 意思決定 + エントリー/損切/利確表示） =====
    function badge(txt, kind){
      const cls = kind === 'green' ? 'b-green' : kind === 'red' ? 'b-red' : 'b-gray';
      return `<span class="badge ${cls}">${txt}</span>`;
    }
    function fmt(x, d=2){ return (x===null || x===undefined) ? '-' : Number(x).toFixed(d); }

    async function loadEvidence(input){
      const ticker = normalizeTicker(input);
      const box = document.getElementById('evidence');
      const grid = document.getElementById('ev-grid');
      const asof = document.getElementById('ev-asof');
      const err  = document.getElementById('ev-error');
      const dec  = document.getElementById('ev-decision');
      box.style.display = 'none';
      err.style.display = 'none'; err.textContent = ''; dec.innerHTML = '';
      try{
        const r = await fetch(`/api/metrics?ticker=${encodeURIComponent(ticker)}`);
        const j = await r.json();
        if(!j.ok){
          err.textContent = j.error || 'メトリクス取得に失敗しました';
          err.style.display = 'block';
          box.style.display = 'block';
          return;
        }
        asof.textContent = `根拠（${j.asof} 時点）`;
        grid.innerHTML = '';

        // === 意思決定（前段で導入済・ここは表示のみ） ===
        // 例: バックエンドで decision を用意するならここで解釈
        // 今回は省略（必要ならここにBUY/WATCH/AVOIDバッジを描画）

        // === ② エントリー/損切り/利確（新規） ===
        const tr = j.trade || {};
        latestTrade = { entry: tr.entry ?? null, stop: tr.stop ?? null, take: tr.take ?? null };

        grid.insertAdjacentHTML('beforeend', `
          <div class="kpi"><h4>Entry</h4><div class="v">${fmt(tr.entry)}</div></div>
          <div class="kpi"><h4>Stop</h4><div class="v">${tr.stop ? fmt(tr.stop) : '-'}</div></div>
          <div class="kpi"><h4>Take (R=${fmt(tr.rr,1)})</h4><div class="v">${tr.take ? fmt(tr.take) : '-'}</div></div>
          <div class="kpi"><h4>MA20(参考)</h4><div class="v">${j.trend?.ma ? fmt(j.trend.ma["20"]) : '-'}</div></div>
          <div class="kpi" style="grid-column: 1 / -1;">
            <h4>計算ロジック</h4><div class="v" style="font-size:12px;font-weight:500;">${tr.method || '-'}</div>
          </div>
        `);

        // ★ ライン反映のため、evidence読み込み後にチャート再描画
        // （描画順: 先にdrawChart→evidenceでlatestTrade更新→再描画）
        const t = tickerEl.value.trim();
        if (t) drawChart(t);

        box.style.display = 'block';
      }catch(e){
        const errBox = document.getElementById('ev-error');
        errBox.textContent = `メトリクス取得エラー: ${e}`;
        errBox.style.display = 'block';
        document.getElementById('evidence').style.display = 'block';
      }
    }

    // HTMXでカードが更新されたら、同一ティッカーでチャート＋根拠も更新
    document.body.addEventListener('htmx:afterOnLoad', () => {
      const t = tickerEl.value.trim();
      if (t){
        // 1回目描画
        drawChart(t);
        // evidenceでtrade計算→ライン注入のため再描画
        loadEvidence(t);
      }
    });
  </script>
</body>
</html>
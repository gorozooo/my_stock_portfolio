{# templates/realized/_monthly_chart.html #}
<div class="mt-6 rounded-2xl bg-white/5 p-3">
  <div class="flex items-center justify-between mb-2">
    <div class="text-sm text-slate-300">月次サマリー</div>
    <div class="text-xs text-slate-400">📈 PnL（投資家損益） / 💰 現金フロー</div>
  </div>

  <div style="height:240px">
    <canvas id="pnlChart" style="width:100%;height:100%"></canvas>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(function () {
  const el = document.getElementById('pnlChart');
  if (!el) return;

  // 2x 解像度でにじみ対策
  const resizeCanvasForHiDPI = (canvas) => {
    const ratio = Math.max(1, window.devicePixelRatio || 1);
    const r = canvas.getBoundingClientRect();
    const w = Math.round(r.width  * ratio);
    const h = Math.round(r.height * ratio);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width  = w;
      canvas.height = h;
      canvas.style.width  = r.width + 'px';
      canvas.style.height = r.height + 'px';
    }
  };

  let chart = null;

  async function fetchData() {
    const qEl = document.querySelector('#q');
    const q   = qEl ? encodeURIComponent(qEl.value || '') : '';
    const res = await fetch("{% url 'realized_chart_monthly' %}?q=" + q, { credentials: 'same-origin' });
    return await res.json();
  }

  async function draw(force = false) {
    // 画面外でゼロサイズのときは何もしない（可視になったら描く）
    const rect = el.getBoundingClientRect();
    if (!force && (rect.width === 0 || rect.height === 0)) return;

    const data = await fetchData();

    const cashColors = data.cash.map(v => v >= 0 ? 'rgba(59,130,246,0.55)' : 'rgba(244,63,94,0.65)');

    if (chart) {
      chart.destroy();
      chart = null;
    }

    const ctx = el.getContext('2d');
    resizeCanvasForHiDPI(el);

    chart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: data.labels,
    datasets: [
      // 💰現金（棒）
      {
        type: 'bar',
        label: '💰 現金',
        data: data.cash,
        backgroundColor: cashColors,
        borderWidth: 0,
        yAxisID: 'y',
        order: 2
      },
      // 📈PnL（月次：折れ線）
      {
        type: 'line',
        label: '📈 PnL',
        data: data.pnl,
        borderColor: 'rgba(16,185,129,1)',
        backgroundColor: 'rgba(16,185,129,0.15)',
        pointRadius: 3,
        pointHoverRadius: 4,
        tension: 0.25,
        fill: false,
        yAxisID: 'y',
        order: 1
      },
      // 📈累積PnL（右軸：折れ線）
      {
        type: 'line',
        label: '📈 累積PnL',
        data: data.pnl_cum,
        borderColor: 'rgba(234,179,8,1)',        // amber
        backgroundColor: 'rgba(234,179,8,0.15)',
        pointRadius: 3,
        pointHoverRadius: 4,
        tension: 0.2,
        fill: false,
        yAxisID: 'y2',
        order: 0
      }
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: 'index', intersect: false },
    plugins: {
      legend: { labels: { color: '#e5e7eb' } },
      tooltip: {
        callbacks: {
          label: (ctx) => {
            const v = ctx.parsed.y ?? 0;
            return `${ctx.dataset.label}: ¥${Number(v).toLocaleString()}`;
          }
        }
      }
    },
    scales: {
      x: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(148,163,184,0.12)' } },
      // 左軸（棒＆月次PnL）
      y: {
        ticks: { color: '#cbd5e1', callback: v => '¥' + Number(v).toLocaleString() },
        grid:  { color: 'rgba(148,163,184,0.12)' }
      },
      // 右軸（累積PnL）
      y2: {
        position: 'right',
        ticks: { color: '#fbbf24', callback: v => '¥' + Number(v).toLocaleString() },
        grid:  { drawOnChartArea: false }
      }
    }
  }
});

  // 初回描画
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => draw(true), { once: true });
  } else {
    draw(true);
  }

  // キーワード変更で再描画
  const qEl = document.querySelector('#q');
  if (qEl) {
    ['change','blur','keydown'].forEach(ev => {
      qEl.addEventListener(ev, (e) => {
        if (ev !== 'keydown' || e.key === 'Enter') draw(true);
      });
    });
  }

  // HTMX 更新後も再描画
  document.body.addEventListener('htmx:afterSwap', (e) => {
    if (!e.target) return;
    if (['pnlTableWrap','pnlSummaryWrap','pnlPeriodWrap'].includes(e.target.id)) {
      draw(true);
    }
  });

  // iOS Safari 対策：可視領域に戻ったら再描画（スクロール/ツールバー変化で消える対策）
  const io = new IntersectionObserver((entries) => {
    const ent = entries[0];
    if (ent && ent.isIntersecting) {
      // サイズ再計算して軽めに更新
      if (chart && chart.chartArea) {
        resizeCanvasForHiDPI(el);
        chart.resize();
        chart.update('none');
      } else {
        draw(true);
      }
    }
  }, { threshold: 0.2 });
  io.observe(el);

  // 端末回転やアドレスバー伸縮での高さ変化にも追従
  let rT = null;
  window.addEventListener('resize', () => {
    clearTimeout(rT);
    rT = setTimeout(() => {
      if (!chart) return;
      resizeCanvasForHiDPI(el);
      chart.resize();
      chart.update('none');
    }, 100);
  });

  // bfcache 復帰時（iOSでよく起きる）
  window.addEventListener('pageshow', () => draw(true));
})();
</script>
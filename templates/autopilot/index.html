{% extends "base.html" %}
{% block title %}オートパイロット（β）{% endblock %}

{% block head %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b0f1a; --card: rgba(255,255,255,0.06); --sub:#94a3b8; --fg:#f1f5f9;
      --accent:#2563eb; --ok:#16a34a; --warn:#f59e0b; --bad:#ef4444; --muted:#334155;
    }
    body{background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    h1{font-size:22px;margin:10px 0 14px}
    .row{display:flex;gap:8px;align-items:center}
    .inp{flex:1;padding:12px;border:1px solid var(--muted);border-radius:12px;background:#1e293b;color:#fff}
    .btn{padding:12px 16px;border:0;border-radius:12px;background:var(--accent);color:#fff;font-weight:700}
    .btn:disabled{opacity:.5}
    .btn-ghost{background:transparent;border:1px solid var(--muted);color:#fff;border-radius:12px;padding:12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px;margin-top:12px}
    .sub{color:var(--sub);font-size:13px}
    .kpis{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
    .kpi{background:rgba(255,255,255,.05);padding:10px;border-radius:10px}
    .kpi h4{margin:0 0 4px;font-size:12px;color:#cbd5e1}
    .kpi .v{font-weight:700}
    .badge{display:inline-block;padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px}
    .b-ok{background:var(--ok);color:#fff}.b-warn{background:var(--warn);color:#222}.b-bad{background:var(--bad);color:#fff}.b-mute{background:var(--muted);color:#e2e8f0}
    .chart{height:300px;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:8px;margin-top:12px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .field{display:flex;gap:8px;align-items:center}
    .num{width:120px;padding:10px;border:1px solid var(--muted);border-radius:10px;background:#1e293b;color:#fff}
    .sticky-actions{position:sticky;bottom:8px;z-index:5;display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
    .tiny{font-size:12px}
  </style>

  <!-- CSRF for htmx / fetch (page-local) -->
  <script>
    function _getCookie(name){ const m=document.cookie.match('(^|;)\\s*'+name+'=([^;]+)'); return m?m.pop():''; }
    document.addEventListener('DOMContentLoaded',()=> {
      document.body.addEventListener('htmx:configRequest', e=>{
        const t=_getCookie('csrftoken'); if(t) e.detail.headers['X-CSRFToken']=t;
      });
    });
  </script>
{% endblock %}

{% block content %}
  <h1>🧭 オートパイロット（β）</h1>

  <!-- Search -->
  <div class="row">
    <input id="tkr" class="inp" placeholder="銘柄コード / ティッカー（例: 6203 / AAPL）" inputmode="latin" />
    <button class="btn" id="goBtn">判定</button>
  </div>
  <div class="sub">AIが「トレンド×需給×リスク」を学習してスコア化します。</div>

  <!-- Verdict + Action -->
  <div class="card" id="verdict" style="display:none;">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div id="titleBox" style="font-weight:800;font-size:18px;line-height:1.1">—</div>
        <div class="sub" id="asof">—</div>
        <div id="verdictBadge" style="margin-top:6px"></div>
      </div>
      <div class="field">
        <button class="badge b-ok" id="sideLong">買い</button>
        <button class="badge b-bad" id="sideShort">売り</button>
      </div>
    </div>

    <div class="kpis" style="margin-top:10px">
      <div class="kpi"><h4>トレンド傾き(60日年率)</h4><div class="v" id="vSlope">-</div></div>
      <div class="kpi"><h4>ADX(14)</h4><div class="v" id="vAdx">-</div></div>
      <div class="kpi"><h4>RS(6M,指数比)</h4><div class="v" id="vRs">-</div></div>
      <div class="kpi"><h4>MA整列</h4><div class="v" id="vMa">-</div></div>
      <div class="kpi"><h4>52週高値まで</h4><div class="v" id="vHi">-</div></div>
      <div class="kpi"><h4>ATR(14)</h4><div class="v" id="vAtr">-</div></div>
    </div>

    <!-- Chart -->
    <div class="chart"><canvas id="c"></canvas></div>

    <!-- Plan -->
    <div class="grid2" style="margin-top:12px">
      <div class="card">
        <div class="sub">📌 推奨プラン（AI原案 → ガード調整後）</div>
        <div class="field"><b>原案・推奨建値</b><span id="pEntryRaw">-</span></div>
        <div class="field"><b>調整後・建値</b><span id="pEntryAdj">-</span></div>
        <div class="field"><b>損切ライン</b><span id="pStop">-</span></div>
        <div class="field"><b>利確めやす</b><span id="pTargets">-</span></div>
        <div class="field"><b>推奨数量</b>
          <input id="qty" class="num" type="number" min="1" step="1" />
          <span class="tiny sub" id="qtyHint"></span>
        </div>
        <div class="tiny sub" id="guardMsg" style="margin-top:6px"></div>
        <div class="sub" id="planMsg" style="margin-top:6px"></div>
      </div>

      <div class="card">
        <div class="sub">🧠 現在のAIポリシー（advisor/policy）</div>
        <div id="policyBox" class="tiny" style="line-height:1.6"></div>
        <div class="row" style="margin-top:8px">
          <button class="btn-ghost" id="btnRefreshPolicy">ポリシー再取得</button>
          <button class="btn" id="btnLearn">学習を実行</button>
        </div>
        <div class="sub" id="learnMsg" style="margin-top:6px"></div>
      </div>
    </div>

    <!-- Sticky actions -->
    <div class="sticky-actions">
      <button class="btn-ghost" id="btnWatch">⭐ ウォッチ</button>
      <button class="btn" id="btnAdd">📥 注文プランに追加</button>
    </div>
  </div>

  <script>
    const el = (id)=>document.getElementById(id);
    let chart, CURRENT={ ticker:"", side:"LONG", metrics:null, policy:null, lastClose:null, name:"" };

    // --- utils
    function norm(t){ if(!t) return ""; t=t.trim().toUpperCase(); if(t.includes('.')) return t; return /^[0-9A-Z]{4,5}$/.test(t)? t+".T":t; }
    function num(x, d=2){ if(x===null||x===undefined||isNaN(x)) return "-"; return Number(x).toLocaleString(undefined,{maximumFractionDigits:d});}
    function badge(label){
      if(label==="BUY") return `<span class="badge b-ok">✅ 買い候補</span>`;
      if(label==="SELL") return `<span class="badge b-bad">📉 売り候補</span>`;
      if(label==="WATCH") return `<span class="badge b-warn">👀 観察</span>`;
      return `<span class="badge b-mute">…評価中</span>`;
    }
    async function fetchJSON(url){ const r=await fetch(url,{credentials:'same-origin'}); if(!r.ok) throw new Error(`HTTP ${r.status}`); return await r.json(); }

    // --- name
    async function fetchName(tickerOrCode){
      try{
        const url = `/api/ticker-name?code=${encodeURIComponent(tickerOrCode)}`;
        const r = await fetch(url, {credentials:'same-origin', cache:'no-store'});
        if(!r.ok) return ""; const j = await r.json(); return j?.name || "";
      }catch{ return ""; }
    }
    function setTitle(ticker, name){ const label = name ? `${name}（${ticker}）` : ticker; el("titleBox").textContent = label; }

    // --- policy
    async function loadPolicy(){
      try{
        const p = await fetchJSON("/advisor/policy");
        CURRENT.policy = p;
        el("policyBox").innerHTML = `<pre style="white-space:pre-wrap">${JSON.stringify(p, null, 2)}</pre>`;
        el("learnMsg").textContent = "";
      }catch(e){ el("policyBox").textContent = "ポリシー取得に失敗: "+e; }
    }
    async function runLearn(){
      el("learnMsg").textContent = "学習中…";
      try{
        const r = await fetch("/advisor/learn", {method:"POST", headers:{'X-CSRFToken': _getCookie('csrftoken')}});
        if(!r.ok) throw new Error(`HTTP ${r.status}`);
        await r.json().catch(()=> ({}));
        el("learnMsg").textContent = "✅ 学習完了。ポリシーを更新しました。";
        loadPolicy();
      }catch(e){ el("learnMsg").textContent = "❌ 学習失敗: "+e; }
    }

    // --- guardrail logic（建値ガード）
    function roundToTick(price){ if(price==null) return null; return Math.round(Number(price)); } // 1円刻み簡易
    function guardrailAdjust(m, rawEntry, lastClose){
      const rel = m.relative||{}; const risk = m.risk||{};
      const atr = Number(risk?.atr14||0);
      const hiPct = Number(rel?.from_52w_high_pct); // 52週高値まで(%)

      let entry = Number(rawEntry); let note=[];
      // 高値圏(±2%以内)なら 2% 抑制
      if (hiPct !== null && !isNaN(hiPct) && hiPct > -2 && hiPct < 2) {
        const capped = entry * 0.98; if (capped < entry){ entry = capped; note.push("高値圏のため2%抑制"); }
      }
      // 直近終値 + 0.5ATR を上限
      if (lastClose && atr){ const cap = Number(lastClose) + 0.5*atr; if(entry > cap){ entry = cap; note.push("直近終値+0.5ATRを上限"); } }
      entry = roundToTick(entry);
      return { entryAdj: entry, guardNote: note.join(" / ") };
    }

    // --- 代替 Targets（R/ATRベース）
    function fallbackTargets(m, entry, stop, side){
      if (!entry || !stop) return [];
      const risk = Math.abs(entry - stop); if (risk <= 0) return [];

      const atr = Number(m?.risk?.atr14 || 0);
      const fromHiPct = Number(m?.relative?.from_52w_high_pct);
      const fromLoPct = Number(m?.relative?.from_52w_low_pct);

      const baseR = [1, 2, 3].map(r => (side === "SHORT" ? entry - r*risk : entry + r*risk));
      let atrCand = [];
      if (atr > 0){
        const a = 1.5*atr, b = 2.5*atr;
        atrCand = (side === "SHORT")
          ? [entry - a, entry - b]
          : [entry + a, entry + b];
      }
      // 近すぎる極端値を抑える
      const clampHigh = p => {
        if (Number.isFinite(fromHiPct) && fromHiPct > -2 && fromHiPct < 2) { // 高値圏±2%
          return Math.min(p, entry + 2 * risk);
        }
        return p;
      };
      const clampLow = p => {
        if (Number.isFinite(fromLoPct) && fromLoPct > -2 && fromLoPct < 2) { // 安値圏±2%
          return Math.max(p, entry - 2 * risk);
        }
        return p;
      };

      let candidates = [...baseR, ...atrCand];
      candidates = candidates.map(p => side === "SHORT" ? clampLow(p) : clampHigh(p));

      const round = x => Math.round(Number(x));
      const uniq = arr => Array.from(new Set(arr.map(v => round(v))));
      const arr = uniq(candidates).sort((a,b)=> side==="SHORT" ? b-a : a-b);

      return arr.slice(0, 3);
    }

    // --- 代替 Qty（残高×リスク% / 1株損失）
    function fallbackQty(m, entry, stop){
      const riskPerShare = Math.abs(entry - stop);
      if (!riskPerShare) return 0;
      const sizing = m?.sizing || {};
      const equity = Number(sizing.equity ?? 1_000_000); // 100万円
      const riskPct = Number(sizing.risk_pct ?? 1);      // 1%
      const lot     = Number(sizing.lot ?? 100);         // 日本株単元100
      const riskAmount = equity * (riskPct / 100);
      let q = Math.floor((riskAmount / riskPerShare) / lot) * lot;
      return Math.max(0, q);
    }

    // --- decision
    function decideLabel(m){
      const slope = m.trend?.slope_ann_pct_60 ?? 0;
      const adx = m.trend?.adx14 ?? 0;
      const rs  = m.relative?.rs_6m_pct ?? 0;
      const adv = m.liquidity?.adv20 ?? 0;
      const p = CURRENT.policy || {};
      const minSlope = p.min_slope ?? 20;
      const minAdx   = p.min_adx   ?? 18;
      const minRS6   = p.min_rs6   ?? 0;
      const minADV   = p.min_adv   ?? 1_0000_0000;
      if (slope >= minSlope && adx >= minAdx && rs >= minRS6 && adv >= minADV) return "BUY";
      if (slope < 0 && adx >= minAdx) return "SELL";
      return "WATCH";
    }

    // --- main render
    async function renderFor(t){
      if(!t) return;
      const ticker = norm(t); CURRENT.ticker = ticker;
      el("verdict").style.display="block";
      el("verdictBadge").innerHTML = `<span class="badge b-mute">…計算中</span>`;

      // name fetch parallel
      const namePromise = fetchName(ticker.replace(".T",""));

      try{
        const m = await fetchJSON(`/api/metrics?ticker=${encodeURIComponent(ticker)}`);
        if(!m.ok) throw new Error(m.error||"metrics error");
        CURRENT.metrics = m;
        el("asof").textContent = `評価時点：${m.asof}`;

        CURRENT.name = await namePromise; setTitle(ticker, CURRENT.name);

        // KPI
        const slope = m.trend?.slope_ann_pct_60 ?? 0;
        const adx   = m.trend?.adx14 ?? 0;
        const rs6   = m.relative?.rs_6m_pct ?? null;
        const atr   = m.risk?.atr14 ?? null;
        const relHi = m.relative?.from_52w_high_pct ?? null;
        el("vSlope").textContent = num(slope,2)+"%";
        el("vAdx").textContent   = num(adx,2);
        el("vRs").textContent    = rs6===null? "-" : num(rs6,2)+"%";
        el("vAtr").textContent   = num(atr,0);
        el("vHi").textContent    = relHi===null? "-" : num(relHi,2)+"%";
        el("vMa").textContent    = (m.trend?.ma?.stack==="bull"?"強":(m.trend?.ma?.stack==="bear"?"弱":"中立"));

        // Verdict
        const label = decideLabel(m);
        el("verdictBadge").innerHTML = badge(label);
        CURRENT.side = (label==="SELL")? "SHORT" : "LONG";
        el("sideLong").style.opacity = CURRENT.side==="LONG" ? "1" : "0.5";
        el("sideShort").style.opacity= CURRENT.side==="SHORT"? "1" : "0.5";

        // OHLC + lastClose
        const r = await fetchJSON(`/api/ohlc?ticker=${encodeURIComponent(ticker)}&days=180`);
        CURRENT.lastClose = (Array.isArray(r?.close) && r.close.length)? Number(r.close[r.close.length-1]) : null;

        // Plan（raw → adjusted）
        const lv = m.levels || {};
        const rawEntry = lv.entry ?? null;
        const stop = lv.stop ?? null;
        let entryAdj = rawEntry; let guardNote="";
        if (rawEntry){
          const g = guardrailAdjust(m, rawEntry, CURRENT.lastClose);
          entryAdj = g.entryAdj; guardNote = g.guardNote;
        }
        el("pEntryRaw").textContent = rawEntry? `${num(rawEntry,0)} 円` : "-";
        el("pEntryAdj").textContent = entryAdj? `${num(entryAdj,0)} 円` : "-";
        el("pStop").textContent     = stop? `${num(stop,0)} 円` : "-";

        // ★ 利確めやす（サーバ優先→無ければ代替）
        let targets = Array.isArray(m.targets) ? m.targets.slice() : [];
        if (!targets.length) {
          targets = fallbackTargets(m, entryAdj || rawEntry, stop, CURRENT.side);
        }
        el("pTargets").textContent  = (targets && targets.length)
          ? targets.map(x=>num(x,0)).join(" / ")
          : "-";

        // ★ 推奨数量（サーバ優先→無ければ代替）
        let qty = (m.sizing?.qty || 0) | 0;
        if (!qty && entryAdj && stop) {
          qty = fallbackQty(m, entryAdj, stop);
        }
        el("qty").value = qty>0? qty : "";
        el("qtyHint").textContent = qty>0? `提案: ${qty}株` : "数量を入力してください";
        el("guardMsg").textContent  = guardNote ? `⚠️ ガード適用: ${guardNote}` : "";

        // Chart
        const ctx = el("c").getContext("2d");
        if(chart) chart.destroy();
        chart = new Chart(ctx,{ type:'line',
          data:{ labels:r.labels, datasets:[
            {label:'Close', data:r?.close||[], borderWidth:2, pointRadius:0},
            {label:'MA(10)',data:r?.ma10 ||[], borderWidth:1, pointRadius:0},
            {label:'MA(30)',data:r?.ma30 ||[], borderWidth:1, pointRadius:0}
          ]},
          options:{responsive:true, maintainAspectRatio:false,
            interaction:{mode:'index',intersect:false},
            scales:{x:{display:false}, y:{beginAtZero:false}}
          }
        });
        const n = (r.labels||[]).length;
        const addLine=(label,val,color,dash)=>{ if(val==null) return; chart.data.datasets.push({type:'line',label:label,data:Array(n).fill(Number(val)),borderWidth:1.2,pointRadius:0,borderDash:dash||[6,4],borderColor:color});};
        addLine("推奨建値(調整後)", entryAdj, "#16a34a",[4,4]);
        addLine("損切ライン", stop , "#ef4444",[6,4]);
        addLine("高値目安",  lv.swing_high,"#60a5fa",[2,4]);
        addLine("安値目安",  lv.swing_low, "#a78bfa",[2,4]);
        chart.update();

      }catch(e){
        el("verdictBadge").innerHTML = `<span class="badge b-bad">❌ 取得失敗</span>`;
        console.error(e);
      }
    }

    // --- interactions
    el("goBtn").addEventListener("click", ()=> renderFor(el("tkr").value));
    el("sideLong").addEventListener("click", ()=>{ CURRENT.side="LONG"; el("sideLong").style.opacity="1"; el("sideShort").style.opacity=".5"; });
    el("sideShort").addEventListener("click",()=>{ CURRENT.side="SHORT"; el("sideShort").style.opacity="1"; el("sideLong").style.opacity=".5"; });
    el("btnRefreshPolicy").addEventListener("click", loadPolicy);
    el("btnLearn").addEventListener("click", runLearn);
    el("btnWatch").addEventListener("click", ()=> alert("ウォッチに追加しました（仮）。後で通知連携に繋ぎます。"));

    // 保存（調整後建値＆代替ターゲットも送信）
    el("btnAdd").addEventListener("click", async ()=>{
      const m = CURRENT.metrics||{}; const lv=m.levels||{}; const qty = Number(el("qty").value||0);
      const msg = el("planMsg"); msg.textContent="";
      if(!lv.stop){ msg.textContent="損切ラインが不足しています"; return; }
      if(!qty || qty<=0){ msg.textContent="数量を入力してください"; return; }

      // 調整後の建値
      const g = guardrailAdjust(m, lv.entry, CURRENT.lastClose);
      const entryUse = g.entryAdj;

      // サーバtargetsが無ければ代替targets
      let targets = Array.isArray(m.targets) ? m.targets.slice() : [];
      if (!targets.length) {
        targets = fallbackTargets(m, entryUse, lv.stop, CURRENT.side);
      }

      const form = new URLSearchParams();
      form.set("ticker", CURRENT.ticker);
      form.set("side",   CURRENT.side);
      form.set("entry",  String(entryUse));
      form.set("stop",   String(lv.stop));
      form.set("qty",    String(qty));
      (targets||[]).forEach(t=> form.append("targets[]", String(t)));

      try{
        const r = await fetch("/api/positions/add", {
          method:"POST",
          headers:{'Content-Type':'application/x-www-form-urlencoded','X-CSRFToken': _getCookie('csrftoken')},
          body:form
        });
        const j = await r.json().catch(()=> ({}));
        if(r.ok && j.ok){ msg.textContent = "✅ 登録しました。/positions/ で確認できます。"; }
        else{ msg.textContent = "❌ 登録に失敗: "+(j.error||("HTTP "+r.status)); }
      }catch(e){ msg.textContent = "❌ 通信エラー: "+e; }
    });

    // onload
    loadPolicy();
  </script>
{% endblock %}
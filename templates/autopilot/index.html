{% extends "base.html" %}
{% block title %}ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆï¼ˆÎ²ï¼‰{% endblock %}

{% block head %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #0b0f1a; --card: rgba(255,255,255,0.06); --sub:#94a3b8; --fg:#f1f5f9;
      --accent:#2563eb; --ok:#16a34a; --warn:#f59e0b; --bad:#ef4444; --muted:#334155;
    }
    body{background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    h1{font-size:22px;margin:10px 0 14px}
    .row{display:flex;gap:8px;align-items:center}
    .inp{flex:1;padding:12px;border:1px solid var(--muted);border-radius:12px;background:#1e293b;color:#fff}
    .btn{padding:12px 16px;border:0;border-radius:12px;background:var(--accent);color:#fff;font-weight:700}
    .btn:disabled{opacity:.5}
    .btn-ghost{background:transparent;border:1px solid var(--muted);color:#fff;border-radius:12px;padding:12px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px;margin-top:12px}
    .sub{color:var(--sub);font-size:13px}
    .kpis{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px}
    .kpi{background:rgba(255,255,255,.05);padding:10px;border-radius:10px}
    .kpi h4{margin:0 0 4px;font-size:12px;color:#cbd5e1}
    .kpi .v{font-weight:700}
    .badge{display:inline-block;padding:6px 10px;border-radius:999px;font-weight:700;font-size:13px}
    .b-ok{background:var(--ok);color:#fff}.b-warn{background:var(--warn);color:#222}.b-bad{background:var(--bad);color:#fff}.b-mute{background:var(--muted);color:#e2e8f0}
    .chart{height:300px;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:8px;margin-top:12px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .field{display:flex;gap:8px;align-items:center}
    .num{width:120px;padding:10px;border:1px solid var(--muted);border-radius:10px;background:#1e293b;color:#fff}
    .sticky-actions{position:sticky;bottom:8px;z-index:5;display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
    .tiny{font-size:12px}
  </style>

  <!-- CSRF for htmx / fetch (page-local) -->
  <script>
    function _getCookie(name){ const m=document.cookie.match('(^|;)\\s*'+name+'=([^;]+)'); return m?m.pop():''; }
    document.addEventListener('DOMContentLoaded',()=> {
      document.body.addEventListener('htmx:configRequest', e=>{
        const t=_getCookie('csrftoken'); if(t) e.detail.headers['X-CSRFToken']=t;
      });
    });
  </script>
{% endblock %}

{% block content %}
  <h1>ğŸ§­ ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆï¼ˆÎ²ï¼‰</h1>

  <!-- Search -->
  <div class="row">
    <input id="tkr" class="inp" placeholder="éŠ˜æŸ„ã‚³ãƒ¼ãƒ‰ / ãƒ†ã‚£ãƒƒã‚«ãƒ¼ï¼ˆä¾‹: 6203 / AAPLï¼‰" inputmode="latin" />
    <button class="btn" id="goBtn">åˆ¤å®š</button>
  </div>
  <div class="sub">AIãŒã€Œãƒˆãƒ¬ãƒ³ãƒ‰Ã—éœ€çµ¦Ã—ãƒªã‚¹ã‚¯ã€ã‚’å­¦ç¿’ã—ã¦ã‚¹ã‚³ã‚¢åŒ–ã—ã¾ã™ã€‚</div>

  <!-- Verdict + Action -->
  <div class="card" id="verdict" style="display:none;">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div id="titleBox" style="font-weight:800;font-size:18px;line-height:1.1">â€”</div>
        <div class="sub" id="asof">â€”</div>
        <div id="verdictBadge" style="margin-top:6px"></div>
      </div>
      <div class="field">
        <button class="badge b-ok" id="sideLong">è²·ã„</button>
        <button class="badge b-bad" id="sideShort">å£²ã‚Š</button>
      </div>
    </div>

    <div class="kpis" style="margin-top:10px">
      <div class="kpi"><h4>ãƒˆãƒ¬ãƒ³ãƒ‰å‚¾ã(60æ—¥å¹´ç‡)</h4><div class="v" id="vSlope">-</div></div>
      <div class="kpi"><h4>ADX(14)</h4><div class="v" id="vAdx">-</div></div>
      <div class="kpi"><h4>RS(6M,æŒ‡æ•°æ¯”)</h4><div class="v" id="vRs">-</div></div>
      <div class="kpi"><h4>MAæ•´åˆ—</h4><div class="v" id="vMa">-</div></div>
      <div class="kpi"><h4>52é€±é«˜å€¤ã¾ã§</h4><div class="v" id="vHi">-</div></div>
      <div class="kpi"><h4>ATR(14)</h4><div class="v" id="vAtr">-</div></div>
    </div>

    <!-- Chart -->
    <div class="chart"><canvas id="c"></canvas></div>

    <!-- Plan -->
    <div class="grid2" style="margin-top:12px">
      <div class="card">
        <div class="sub">ğŸ“Œ æ¨å¥¨ãƒ—ãƒ©ãƒ³ï¼ˆAIåŸæ¡ˆ â†’ ã‚¬ãƒ¼ãƒ‰èª¿æ•´å¾Œï¼‰</div>
        <div class="field"><b>åŸæ¡ˆãƒ»æ¨å¥¨å»ºå€¤</b><span id="pEntryRaw">-</span></div>
        <div class="field"><b>èª¿æ•´å¾Œãƒ»å»ºå€¤</b><span id="pEntryAdj">-</span></div>
        <div class="field"><b>æåˆ‡ãƒ©ã‚¤ãƒ³</b><span id="pStop">-</span></div>
        <div class="field"><b>åˆ©ç¢ºã‚ã‚„ã™</b><span id="pTargets">-</span></div>
        <div class="field"><b>æ¨å¥¨æ•°é‡</b>
          <input id="qty" class="num" type="number" min="1" step="1" />
          <span class="tiny sub" id="qtyHint"></span>
        </div>
        <div class="tiny sub" id="guardMsg" style="margin-top:6px"></div>
        <div class="sub" id="planMsg" style="margin-top:6px"></div>
      </div>

      <div class="card">
        <div class="sub">ğŸ§  ç¾åœ¨ã®AIãƒãƒªã‚·ãƒ¼ï¼ˆadvisor/policyï¼‰</div>
        <div id="policyBox" class="tiny" style="line-height:1.6"></div>
        <div class="row" style="margin-top:8px">
          <button class="btn-ghost" id="btnRefreshPolicy">ãƒãƒªã‚·ãƒ¼å†å–å¾—</button>
          <button class="btn" id="btnLearn">å­¦ç¿’ã‚’å®Ÿè¡Œ</button>
        </div>
        <div class="sub" id="learnMsg" style="margin-top:6px"></div>
      </div>
    </div>

    <!-- Sticky actions -->
    <div class="sticky-actions">
      <button class="btn-ghost" id="btnWatch">â­ ã‚¦ã‚©ãƒƒãƒ</button>
      <button class="btn" id="btnAdd">ğŸ“¥ æ³¨æ–‡ãƒ—ãƒ©ãƒ³ã«è¿½åŠ </button>
    </div>
  </div>

  <script>
    const el = (id)=>document.getElementById(id);
    let chart, CURRENT={ ticker:"", side:"LONG", metrics:null, policy:null, lastClose:null, name:"" };

    // --- utils
    function norm(t){ if(!t) return ""; t=t.trim().toUpperCase(); if(t.includes('.')) return t; return /^[0-9A-Z]{4,5}$/.test(t)? t+".T":t; }
    function num(x, d=2){ if(x===null||x===undefined||isNaN(x)) return "-"; return Number(x).toLocaleString(undefined,{maximumFractionDigits:d});}
    function badge(label){
      if(label==="BUY") return `<span class="badge b-ok">âœ… è²·ã„å€™è£œ</span>`;
      if(label==="SELL") return `<span class="badge b-bad">ğŸ“‰ å£²ã‚Šå€™è£œ</span>`;
      if(label==="WATCH") return `<span class="badge b-warn">ğŸ‘€ è¦³å¯Ÿ</span>`;
      return `<span class="badge b-mute">â€¦è©•ä¾¡ä¸­</span>`;
    }
    async function fetchJSON(url){ const r=await fetch(url,{credentials:'same-origin'}); if(!r.ok) throw new Error(`HTTP ${r.status}`); return await r.json(); }

    // --- name
    async function fetchName(tickerOrCode){
      try{
        const url = `/api/ticker-name?code=${encodeURIComponent(tickerOrCode)}`;
        const r = await fetch(url, {credentials:'same-origin', cache:'no-store'});
        if(!r.ok) return ""; const j = await r.json(); return j?.name || "";
      }catch{ return ""; }
    }
    function setTitle(ticker, name){ const label = name ? `${name}ï¼ˆ${ticker}ï¼‰` : ticker; el("titleBox").textContent = label; }

    // --- policy
    async function loadPolicy(){
      try{
        const p = await fetchJSON("/advisor/policy");
        CURRENT.policy = p;
        el("policyBox").innerHTML = `<pre style="white-space:pre-wrap">${JSON.stringify(p, null, 2)}</pre>`;
        el("learnMsg").textContent = "";
      }catch(e){ el("policyBox").textContent = "ãƒãƒªã‚·ãƒ¼å–å¾—ã«å¤±æ•—: "+e; }
    }
    async function runLearn(){
      el("learnMsg").textContent = "å­¦ç¿’ä¸­â€¦";
      try{
        const r = await fetch("/advisor/learn", {method:"POST", headers:{'X-CSRFToken': _getCookie('csrftoken')}});
        if(!r.ok) throw new Error(`HTTP ${r.status}`);
        await r.json().catch(()=> ({}));
        el("learnMsg").textContent = "âœ… å­¦ç¿’å®Œäº†ã€‚ãƒãƒªã‚·ãƒ¼ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚";
        loadPolicy();
      }catch(e){ el("learnMsg").textContent = "âŒ å­¦ç¿’å¤±æ•—: "+e; }
    }

    // --- guardrail logicï¼ˆå»ºå€¤ã‚¬ãƒ¼ãƒ‰ï¼‰
    function roundToTick(price){ if(price==null) return null; return Math.round(Number(price)); } // 1å††åˆ»ã¿ç°¡æ˜“
    function guardrailAdjust(m, rawEntry, lastClose){
      const rel = m.relative||{}; const risk = m.risk||{};
      const atr = Number(risk?.atr14||0);
      const hiPct = Number(rel?.from_52w_high_pct); // 52é€±é«˜å€¤ã¾ã§(%)

      let entry = Number(rawEntry); let note=[];
      // é«˜å€¤åœ(Â±2%ä»¥å†…)ãªã‚‰ 2% æŠ‘åˆ¶
      if (hiPct !== null && !isNaN(hiPct) && hiPct > -2 && hiPct < 2) {
        const capped = entry * 0.98; if (capped < entry){ entry = capped; note.push("é«˜å€¤åœã®ãŸã‚2%æŠ‘åˆ¶"); }
      }
      // ç›´è¿‘çµ‚å€¤ + 0.5ATR ã‚’ä¸Šé™
      if (lastClose && atr){ const cap = Number(lastClose) + 0.5*atr; if(entry > cap){ entry = cap; note.push("ç›´è¿‘çµ‚å€¤+0.5ATRã‚’ä¸Šé™"); } }
      entry = roundToTick(entry);
      return { entryAdj: entry, guardNote: note.join(" / ") };
    }

    // --- ä»£æ›¿ Targetsï¼ˆR/ATRãƒ™ãƒ¼ã‚¹ï¼‰
    function fallbackTargets(m, entry, stop, side){
      if (!entry || !stop) return [];
      const risk = Math.abs(entry - stop); if (risk <= 0) return [];

      const atr = Number(m?.risk?.atr14 || 0);
      const fromHiPct = Number(m?.relative?.from_52w_high_pct);
      const fromLoPct = Number(m?.relative?.from_52w_low_pct);

      const baseR = [1, 2, 3].map(r => (side === "SHORT" ? entry - r*risk : entry + r*risk));
      let atrCand = [];
      if (atr > 0){
        const a = 1.5*atr, b = 2.5*atr;
        atrCand = (side === "SHORT")
          ? [entry - a, entry - b]
          : [entry + a, entry + b];
      }
      // è¿‘ã™ãã‚‹æ¥µç«¯å€¤ã‚’æŠ‘ãˆã‚‹
      const clampHigh = p => {
        if (Number.isFinite(fromHiPct) && fromHiPct > -2 && fromHiPct < 2) { // é«˜å€¤åœÂ±2%
          return Math.min(p, entry + 2 * risk);
        }
        return p;
      };
      const clampLow = p => {
        if (Number.isFinite(fromLoPct) && fromLoPct > -2 && fromLoPct < 2) { // å®‰å€¤åœÂ±2%
          return Math.max(p, entry - 2 * risk);
        }
        return p;
      };

      let candidates = [...baseR, ...atrCand];
      candidates = candidates.map(p => side === "SHORT" ? clampLow(p) : clampHigh(p));

      const round = x => Math.round(Number(x));
      const uniq = arr => Array.from(new Set(arr.map(v => round(v))));
      const arr = uniq(candidates).sort((a,b)=> side==="SHORT" ? b-a : a-b);

      return arr.slice(0, 3);
    }

    // --- ä»£æ›¿ Qtyï¼ˆæ®‹é«˜Ã—ãƒªã‚¹ã‚¯% / 1æ ªæå¤±ï¼‰
    function fallbackQty(m, entry, stop){
      const riskPerShare = Math.abs(entry - stop);
      if (!riskPerShare) return 0;
      const sizing = m?.sizing || {};
      const equity = Number(sizing.equity ?? 1_000_000); // 100ä¸‡å††
      const riskPct = Number(sizing.risk_pct ?? 1);      // 1%
      const lot     = Number(sizing.lot ?? 100);         // æ—¥æœ¬æ ªå˜å…ƒ100
      const riskAmount = equity * (riskPct / 100);
      let q = Math.floor((riskAmount / riskPerShare) / lot) * lot;
      return Math.max(0, q);
    }

    // --- decision
    function decideLabel(m){
      const slope = m.trend?.slope_ann_pct_60 ?? 0;
      const adx = m.trend?.adx14 ?? 0;
      const rs  = m.relative?.rs_6m_pct ?? 0;
      const adv = m.liquidity?.adv20 ?? 0;
      const p = CURRENT.policy || {};
      const minSlope = p.min_slope ?? 20;
      const minAdx   = p.min_adx   ?? 18;
      const minRS6   = p.min_rs6   ?? 0;
      const minADV   = p.min_adv   ?? 1_0000_0000;
      if (slope >= minSlope && adx >= minAdx && rs >= minRS6 && adv >= minADV) return "BUY";
      if (slope < 0 && adx >= minAdx) return "SELL";
      return "WATCH";
    }

    // --- main render
    async function renderFor(t){
      if(!t) return;
      const ticker = norm(t); CURRENT.ticker = ticker;
      el("verdict").style.display="block";
      el("verdictBadge").innerHTML = `<span class="badge b-mute">â€¦è¨ˆç®—ä¸­</span>`;

      // name fetch parallel
      const namePromise = fetchName(ticker.replace(".T",""));

      try{
        const m = await fetchJSON(`/api/metrics?ticker=${encodeURIComponent(ticker)}`);
        if(!m.ok) throw new Error(m.error||"metrics error");
        CURRENT.metrics = m;
        el("asof").textContent = `è©•ä¾¡æ™‚ç‚¹ï¼š${m.asof}`;

        CURRENT.name = await namePromise; setTitle(ticker, CURRENT.name);

        // KPI
        const slope = m.trend?.slope_ann_pct_60 ?? 0;
        const adx   = m.trend?.adx14 ?? 0;
        const rs6   = m.relative?.rs_6m_pct ?? null;
        const atr   = m.risk?.atr14 ?? null;
        const relHi = m.relative?.from_52w_high_pct ?? null;
        el("vSlope").textContent = num(slope,2)+"%";
        el("vAdx").textContent   = num(adx,2);
        el("vRs").textContent    = rs6===null? "-" : num(rs6,2)+"%";
        el("vAtr").textContent   = num(atr,0);
        el("vHi").textContent    = relHi===null? "-" : num(relHi,2)+"%";
        el("vMa").textContent    = (m.trend?.ma?.stack==="bull"?"å¼·":(m.trend?.ma?.stack==="bear"?"å¼±":"ä¸­ç«‹"));

        // Verdict
        const label = decideLabel(m);
        el("verdictBadge").innerHTML = badge(label);
        CURRENT.side = (label==="SELL")? "SHORT" : "LONG";
        el("sideLong").style.opacity = CURRENT.side==="LONG" ? "1" : "0.5";
        el("sideShort").style.opacity= CURRENT.side==="SHORT"? "1" : "0.5";

        // OHLC + lastClose
        const r = await fetchJSON(`/api/ohlc?ticker=${encodeURIComponent(ticker)}&days=180`);
        CURRENT.lastClose = (Array.isArray(r?.close) && r.close.length)? Number(r.close[r.close.length-1]) : null;

        // Planï¼ˆraw â†’ adjustedï¼‰
        const lv = m.levels || {};
        const rawEntry = lv.entry ?? null;
        const stop = lv.stop ?? null;
        let entryAdj = rawEntry; let guardNote="";
        if (rawEntry){
          const g = guardrailAdjust(m, rawEntry, CURRENT.lastClose);
          entryAdj = g.entryAdj; guardNote = g.guardNote;
        }
        el("pEntryRaw").textContent = rawEntry? `${num(rawEntry,0)} å††` : "-";
        el("pEntryAdj").textContent = entryAdj? `${num(entryAdj,0)} å††` : "-";
        el("pStop").textContent     = stop? `${num(stop,0)} å††` : "-";

        // â˜… åˆ©ç¢ºã‚ã‚„ã™ï¼ˆã‚µãƒ¼ãƒå„ªå…ˆâ†’ç„¡ã‘ã‚Œã°ä»£æ›¿ï¼‰
        let targets = Array.isArray(m.targets) ? m.targets.slice() : [];
        if (!targets.length) {
          targets = fallbackTargets(m, entryAdj || rawEntry, stop, CURRENT.side);
        }
        el("pTargets").textContent  = (targets && targets.length)
          ? targets.map(x=>num(x,0)).join(" / ")
          : "-";

        // â˜… æ¨å¥¨æ•°é‡ï¼ˆã‚µãƒ¼ãƒå„ªå…ˆâ†’ç„¡ã‘ã‚Œã°ä»£æ›¿ï¼‰
        let qty = (m.sizing?.qty || 0) | 0;
        if (!qty && entryAdj && stop) {
          qty = fallbackQty(m, entryAdj, stop);
        }
        el("qty").value = qty>0? qty : "";
        el("qtyHint").textContent = qty>0? `ææ¡ˆ: ${qty}æ ª` : "æ•°é‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„";
        el("guardMsg").textContent  = guardNote ? `âš ï¸ ã‚¬ãƒ¼ãƒ‰é©ç”¨: ${guardNote}` : "";

        // Chart
        const ctx = el("c").getContext("2d");
        if(chart) chart.destroy();
        chart = new Chart(ctx,{ type:'line',
          data:{ labels:r.labels, datasets:[
            {label:'Close', data:r?.close||[], borderWidth:2, pointRadius:0},
            {label:'MA(10)',data:r?.ma10 ||[], borderWidth:1, pointRadius:0},
            {label:'MA(30)',data:r?.ma30 ||[], borderWidth:1, pointRadius:0}
          ]},
          options:{responsive:true, maintainAspectRatio:false,
            interaction:{mode:'index',intersect:false},
            scales:{x:{display:false}, y:{beginAtZero:false}}
          }
        });
        const n = (r.labels||[]).length;
        const addLine=(label,val,color,dash)=>{ if(val==null) return; chart.data.datasets.push({type:'line',label:label,data:Array(n).fill(Number(val)),borderWidth:1.2,pointRadius:0,borderDash:dash||[6,4],borderColor:color});};
        addLine("æ¨å¥¨å»ºå€¤(èª¿æ•´å¾Œ)", entryAdj, "#16a34a",[4,4]);
        addLine("æåˆ‡ãƒ©ã‚¤ãƒ³", stop , "#ef4444",[6,4]);
        addLine("é«˜å€¤ç›®å®‰",  lv.swing_high,"#60a5fa",[2,4]);
        addLine("å®‰å€¤ç›®å®‰",  lv.swing_low, "#a78bfa",[2,4]);
        chart.update();

      }catch(e){
        el("verdictBadge").innerHTML = `<span class="badge b-bad">âŒ å–å¾—å¤±æ•—</span>`;
        console.error(e);
      }
    }

    // --- interactions
    el("goBtn").addEventListener("click", ()=> renderFor(el("tkr").value));
    el("sideLong").addEventListener("click", ()=>{ CURRENT.side="LONG"; el("sideLong").style.opacity="1"; el("sideShort").style.opacity=".5"; });
    el("sideShort").addEventListener("click",()=>{ CURRENT.side="SHORT"; el("sideShort").style.opacity="1"; el("sideLong").style.opacity=".5"; });
    el("btnRefreshPolicy").addEventListener("click", loadPolicy);
    el("btnLearn").addEventListener("click", runLearn);
    el("btnWatch").addEventListener("click", ()=> alert("ã‚¦ã‚©ãƒƒãƒã«è¿½åŠ ã—ã¾ã—ãŸï¼ˆä»®ï¼‰ã€‚å¾Œã§é€šçŸ¥é€£æºã«ç¹‹ãã¾ã™ã€‚"));

    // ä¿å­˜ï¼ˆèª¿æ•´å¾Œå»ºå€¤ï¼†ä»£æ›¿ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚‚é€ä¿¡ï¼‰
    el("btnAdd").addEventListener("click", async ()=>{
      const m = CURRENT.metrics||{}; const lv=m.levels||{}; const qty = Number(el("qty").value||0);
      const msg = el("planMsg"); msg.textContent="";
      if(!lv.stop){ msg.textContent="æåˆ‡ãƒ©ã‚¤ãƒ³ãŒä¸è¶³ã—ã¦ã„ã¾ã™"; return; }
      if(!qty || qty<=0){ msg.textContent="æ•°é‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"; return; }

      // èª¿æ•´å¾Œã®å»ºå€¤
      const g = guardrailAdjust(m, lv.entry, CURRENT.lastClose);
      const entryUse = g.entryAdj;

      // ã‚µãƒ¼ãƒtargetsãŒç„¡ã‘ã‚Œã°ä»£æ›¿targets
      let targets = Array.isArray(m.targets) ? m.targets.slice() : [];
      if (!targets.length) {
        targets = fallbackTargets(m, entryUse, lv.stop, CURRENT.side);
      }

      const form = new URLSearchParams();
      form.set("ticker", CURRENT.ticker);
      form.set("side",   CURRENT.side);
      form.set("entry",  String(entryUse));
      form.set("stop",   String(lv.stop));
      form.set("qty",    String(qty));
      (targets||[]).forEach(t=> form.append("targets[]", String(t)));

      try{
        const r = await fetch("/api/positions/add", {
          method:"POST",
          headers:{'Content-Type':'application/x-www-form-urlencoded','X-CSRFToken': _getCookie('csrftoken')},
          body:form
        });
        const j = await r.json().catch(()=> ({}));
        if(r.ok && j.ok){ msg.textContent = "âœ… ç™»éŒ²ã—ã¾ã—ãŸã€‚/positions/ ã§ç¢ºèªã§ãã¾ã™ã€‚"; }
        else{ msg.textContent = "âŒ ç™»éŒ²ã«å¤±æ•—: "+(j.error||("HTTP "+r.status)); }
      }catch(e){ msg.textContent = "âŒ é€šä¿¡ã‚¨ãƒ©ãƒ¼: "+e; }
    });

    // onload
    loadPolicy();
  </script>
{% endblock %}